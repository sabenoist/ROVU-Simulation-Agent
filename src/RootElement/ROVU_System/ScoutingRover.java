// --------------------------------------------------------
// Code generated by Papyrus Java
// --------------------------------------------------------

package RootElement.ROVU_System;

import java.util.Random;

import javax.vecmath.Vector3d;

import RootElement.ROVU_System.Rover;
import simbad.sim.RangeSensorBelt;
import simbad.sim.RobotFactory;

/************************************************************/
/**
 * 
 */
public class ScoutingRover extends Rover {

	boolean running = true;
	int proxcheck = 0;
	int zonecheck = 0;
	int currentDirection;
	RangeSensorBelt sonar;
	int turnAgain = 0;
	Coordinate[][] zoneGrid;
	
	// no GPS requirement
	Coordinate currentPosition;
	
	public ScoutingRover(Vector3d position, String name, Subject s, int initdir) {
		super(position, name);
		this.setInitialPosition(new Coordinate(position.x, position.y, position.z));
		this.setRoverName(name);
		this.setSubject(s);
		this.getSubject().attach(this);
		this.setInitialDirection(initdir);
		this.setType(RoverEnum.SCOUTING_ROVER);
		sonar = RobotFactory.addSonarBeltSensor(this, 4);
		// no GPS requirement
		currentPosition = new Coordinate(position.x, 0.3, position.z);
	}

	/** This method is called by the simulator engine on reset. */
    public void initBehavior() {
        System.out.printf("Initial behavior of %s is executed\n", this.getName());
        switch(this.getInitialDirection()) {
        	case NORTH: rotateY(-Math.PI); currentDirection = NORTH; break;
        	case SOUTH: currentDirection = SOUTH; break;
        	default: break;
        }   
        zoneGrid = this.getZone().getZoneGrid();
        zonecheck = 0;
        proxcheck = 0;     
        turnAgain = 0;
        currentPosition = this.getInitialPosition();
    }
    
    /** This method is call cyclically (20 times per second) by the simulator engine. */
    public void performBehavior() {
    	
    	if(!running){
			return;
		}
    	
    	// time limit for scouting
    	if(this.getCounter() > 120){ // 2400
    		CentralStation cs = (CentralStation)this.getSubject();
    		cs.finishScouting();
    		this.setTranslationalVelocity(0);
    		this.setStatus("stopped");
    		running = false;
    		
    		int zoneSize = zoneGrid.length;
    		switch(this.getZone().getID()){
    			case 0: this.moveToPosition(new Vector3d(-zoneSize-2, 0, -zoneSize-2));
    			case 1: this.moveToPosition(new Vector3d(-zoneSize-2, 0, -zoneSize-1));
    			case 2: this.moveToPosition(new Vector3d(-zoneSize-1, 0, -zoneSize-2));
    			case 3: this.moveToPosition(new Vector3d(-zoneSize-1, 0, -zoneSize-1));
    		}
    		return;
    	}
    	
    	// if for some reason collision is detected (edge case)
    	if(this.collisionDetected()){
    		this.setStatus("turning");
    		this.setTranslationalVelocity(0);
    		rotateY(-(Math.PI)); 
    		currentDirection = (currentDirection + 2) % 4;
    		this.setStatus("forward");
    	}
    	
    	if (this.getCounter() > 0 && this.getTranslationalVelocity() > 0) {
			Coordinate oldPos = currentPosition;
			double distance = this.getTranslationalVelocity() / TICK_RATE;
			switch (currentDirection) {
    			case NORTH:
    				currentPosition = new Coordinate(oldPos.getX()-distance, oldPos.getY(), oldPos.getZ());
    				break;
    			case EAST:
    				currentPosition = new Coordinate(oldPos.getX(), oldPos.getY(), oldPos.getZ()-distance);
    				break;
    			case SOUTH:
    				currentPosition = new Coordinate(oldPos.getX()+distance, oldPos.getY(), oldPos.getZ());
    				break;
    			case WEST:
    				currentPosition = new Coordinate(oldPos.getX(), oldPos.getY(), oldPos.getZ()+distance);
    				break;
			}
		}
    	
    	if(this.getCounter() > 0 && this.getCounter() == turnAgain){
    		turnRandomLeftRight();
    	}
    	
    	if( this.getCounter() > zonecheck )
    	{
        switch(currentDirection){
        case NORTH:{ 
        	boolean outOfBounds = false;
        	switch(this.getZone().getID()){
        		case 0: outOfBounds = checkOutOfBoundsMaxX(currentPosition); break;
        		case 1: outOfBounds = checkOutOfBoundsMaxX(currentPosition); break;
        		case 2: outOfBounds = checkOutOfBoundsMinX(currentPosition); break;
        		case 3: outOfBounds = checkOutOfBoundsMinX(currentPosition); break;
        	}
        	if(outOfBounds){
        		turnAway();
        	}
        	break;
        }
        case EAST:{
        	boolean outOfBounds = false;
        	switch(this.getZone().getID()){
        		case 0: outOfBounds = checkOutOfBoundsMinZ(currentPosition); break;
        		case 1: outOfBounds = checkOutOfBoundsMaxZ(currentPosition); break;
        		case 2: outOfBounds = checkOutOfBoundsMinZ(currentPosition); break;
        		case 3: outOfBounds = checkOutOfBoundsMaxZ(currentPosition); break;
        	}
        	if(outOfBounds){
        		turnAway();
        	}
        	break;
        }
        case SOUTH:{ 
        	boolean outOfBounds = false;
        	switch(this.getZone().getID()){
        		case 0: outOfBounds = checkOutOfBoundsMinX(currentPosition); break;
        		case 1: outOfBounds = checkOutOfBoundsMinX(currentPosition); break;
        		case 2: outOfBounds = checkOutOfBoundsMaxX(currentPosition); break;
        		case 3: outOfBounds = checkOutOfBoundsMaxX(currentPosition); break;
        	}
        	if(outOfBounds){
        		turnAway();
        	}
        	break;
        }
        case WEST:{
        	boolean outOfBounds = false;
        	switch(this.getZone().getID()){
        		case 0: outOfBounds = checkOutOfBoundsMaxZ(currentPosition); break;
        		case 1: outOfBounds = checkOutOfBoundsMinZ(currentPosition); break;
        		case 2: outOfBounds = checkOutOfBoundsMaxZ(currentPosition); break;
        		case 3: outOfBounds = checkOutOfBoundsMinZ(currentPosition); break;
        	}
        	if(outOfBounds){
        		turnAway();
        	}
        	break;
        }
        }
    	}
    	
    	if( this.getCounter() > proxcheck && sonar.getMeasurement(0) <= 0.2 ){
            double x = currentPosition.getX();
            double z = currentPosition.getZ();
            switch(currentDirection){
            	case 0: x-=1; break;
            	case 1: z-=1; break;
            	case 2: x+=1; break;
            	case 3: z+=1; break;
            }
            // round the numbers
            x = Math.round(x*2) / 2.0f;
            z = Math.round(z*2) / 2.0f;
    	
        	Coordinate zoneCoord = this.getZone().getZoneCoord(x, z);
        	if(zoneCoord != null){
        		if(!zoneCoord.isObstacle()){
        			zoneCoord.setObstacle(true);
        			System.out.printf("(%d) Obstacle found at [%.1f][%.1f] in Zone %d.\n", this.getCounter(), x, z, this.getZone().getID());
        		}
        	}
            turnRandomLeftRight();
            // do not instantly check again to avoid multiple reactions to the same obstacle
            proxcheck = this.getCounter() + 10;
		}
    	
    	if(this.getCounter() % 5 == 0) {	
    		this.setStatus("forward");
    		this.setVelocity(0.5);
    		this.setTranslationalVelocity(this.getVelocity());  
    	}
    	
    }
    
    void turnRandomLeftRight(){
		this.setStatus("turning");
		Random r = new Random();
    	int rand = r.nextInt(2);
    	switch(rand){
    	case 0:{
    		rotateY((Math.PI)/2); currentDirection = (currentDirection + 3) % 4;
    		break;
    	}
    	case 1:{
    		rotateY(-(Math.PI)/2); currentDirection = (currentDirection + 1) % 4;
    		break;
    	}
    	}
    	this.setStatus("forward");
    }
    
    boolean checkOutOfBoundsMaxX(Coordinate pos){
    	if(Math.abs(pos.getX()) > Math.abs(zoneGrid[zoneGrid.length-1][zoneGrid.length-1].getX())){
    		return true;
    	}
    	return false;
    }
    boolean checkOutOfBoundsMinX(Coordinate pos){
    	if(Math.abs(pos.getX()) < Math.abs(zoneGrid[0][0].getX())){
    		return true;
    	}
    	return false;
    }
    boolean checkOutOfBoundsMaxZ(Coordinate pos){
    	if(Math.abs(pos.getZ()) > Math.abs(zoneGrid[zoneGrid.length-1][zoneGrid.length-1].getZ())){
    		return true;
    	}
    	return false;
    }
    boolean checkOutOfBoundsMinZ(Coordinate pos){
    	if(Math.abs(pos.getZ()) < Math.abs(zoneGrid[0][0].getZ())){
    		return true;
    	}
    	return false;
    }

    void turnAway(){
		this.setStatus("turning");
		this.setTranslationalVelocity(0);
		rotateY(-(Math.PI)); 
		currentDirection = (currentDirection + 2) % 4;
		double delay = 20 / this.getVelocity();
		Random r = new Random();
    	int rand = r.nextInt(3);
    	if (rand == 0 ){
    		delay *= 2;
    	}
    	if( rand == 1){
    		delay = 1;
    	}
		turnAgain = (int) (this.getCounter() + delay);
        zonecheck = this.getCounter() + 10;
        this.setStatus("forward");
    }
    
	@Override
	public void update() {
		
	}
};
